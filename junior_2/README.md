# üöÄ M√≥dulo 2: Componentes y Hooks B√°sicos

## üìö Descripci√≥n del M√≥dulo

En este m√≥dulo profundizar√°s en el uso de hooks b√°sicos de React, especialmente `useEffect`, y aprender√°s sobre el ciclo de vida de los componentes. Tambi√©n explorar√°s t√©cnicas para crear componentes m√°s reutilizables y manejar efectos secundarios de manera efectiva.

## üéØ Objetivos de Aprendizaje

Al finalizar este m√≥dulo ser√°s capaz de:
- ‚úÖ Entender y usar el hook useEffect correctamente
- ‚úÖ Comprender el ciclo de vida de los componentes funcionales
- ‚úÖ Crear componentes reutilizables y modulares
- ‚úÖ Manejar efectos secundarios (API calls, suscripciones)
- ‚úÖ Implementar limpieza de efectos y suscripciones
- ‚úÖ Crear hooks personalizados b√°sicos
- ‚úÖ Manejar formularios complejos con validaci√≥n
- ‚úÖ Implementar navegaci√≥n b√°sica entre componentes
- ‚úÖ Optimizar re-renderizados con React.memo
- ‚úÖ Debuggear problemas comunes de hooks

## üìñ Contenido Te√≥rico

### 1. El Hook useEffect

`useEffect` es un hook que permite ejecutar c√≥digo despu√©s de que el componente se renderiza, y es fundamental para manejar efectos secundarios.

#### Sintaxis b√°sica:
```jsx
import { useEffect } from 'react';

function MiComponente() {
  useEffect(() => {
    // C√≥digo que se ejecuta despu√©s del renderizado
    console.log('Componente renderizado');
  });

  return <div>Mi componente</div>;
}
```

#### useEffect con array de dependencias:
```jsx
function Contador() {
  const [contador, setContador] = useState(0);
  const [nombre, setNombre] = useState('');

  // Se ejecuta solo cuando cambia 'contador'
  useEffect(() => {
    document.title = `Contador: ${contador}`;
  }, [contador]);

  // Se ejecuta solo cuando cambia 'nombre'
  useEffect(() => {
    console.log(`Nombre cambiado a: ${nombre}`);
  }, [nombre]);

  // Se ejecuta solo una vez (al montar)
  useEffect(() => {
    console.log('Componente montado');
  }, []);

  return (
    <div>
      <p>Contador: {contador}</p>
      <button onClick={() => setContador(contador + 1)}>
        Incrementar
      </button>
      <input
        value={nombre}
        onChange={(e) => setNombre(e.target.value)}
        placeholder="Tu nombre"
      />
    </div>
  );
}
```

#### useEffect con funci√≥n de limpieza:
```jsx
function ChatComponent() {
  const [mensajes, setMensajes] = useState([]);

  useEffect(() => {
    // Suscripci√≥n a un chat
    const suscripcion = chatService.subscribe((nuevoMensaje) => {
      setMensajes(prev => [...prev, nuevoMensaje]);
    });

    // Funci√≥n de limpieza (cleanup)
    return () => {
      suscripcion.unsubscribe();
    };
  }, []);

  return (
    <div>
      {mensajes.map((msg, index) => (
        <p key={index}>{msg.texto}</p>
      ))}
    </div>
  );
}
```

### 2. Ciclo de Vida de Componentes Funcionales

Los componentes funcionales tienen un ciclo de vida que se maneja a trav√©s de hooks:

#### Fases del ciclo de vida:
```jsx
function ComponenteConCicloDeVida() {
  // 1. Montaje (Mount)
  useEffect(() => {
    console.log('Componente montado');
    
    // Configuraci√≥n inicial
    const timer = setInterval(() => {
      console.log('Timer ejecut√°ndose');
    }, 1000);

    // Cleanup al desmontar
    return () => {
      console.log('Componente desmontado');
      clearInterval(timer);
    };
  }, []);

  // 2. Actualizaci√≥n (Update)
  const [contador, setContador] = useState(0);
  
  useEffect(() => {
    console.log('Contador actualizado:', contador);
  }, [contador]);

  // 3. Desmontaje (Unmount) - se maneja en el return del useEffect

  return (
    <div>
      <p>Contador: {contador}</p>
      <button onClick={() => setContador(contador + 1)}>
        Incrementar
      </button>
    </div>
  );
}
```

### 3. Llamadas a APIs con useEffect

#### Fetch b√°sico:
```jsx
function ListaUsuarios() {
  const [usuarios, setUsuarios] = useState([]);
  const [cargando, setCargando] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchUsuarios = async () => {
      try {
        setCargando(true);
        const response = await fetch('https://jsonplaceholder.typicode.com/users');
        const data = await response.json();
        setUsuarios(data);
      } catch (err) {
        setError('Error al cargar usuarios');
        console.error(err);
      } finally {
        setCargando(false);
      }
    };

    fetchUsuarios();
  }, []);

  if (cargando) return <div>Cargando usuarios...</div>;
  if (error) return <div>Error: {error}</div>;

  return (
    <ul>
      {usuarios.map(usuario => (
        <li key={usuario.id}>{usuario.name}</li>
      ))}
    </ul>
  );
}
```

#### Fetch con par√°metros:
```jsx
function UsuarioDetalle({ userId }) {
  const [usuario, setUsuario] = useState(null);
  const [cargando, setCargando] = useState(false);

  useEffect(() => {
    if (!userId) return;

    const fetchUsuario = async () => {
      setCargando(true);
      try {
        const response = await fetch(`https://jsonplaceholder.typicode.com/users/${userId}`);
        const data = await response.json();
        setUsuario(data);
      } catch (err) {
        console.error('Error al cargar usuario:', err);
      } finally {
        setCargando(false);
      }
    };

    fetchUsuario();
  }, [userId]); // Se ejecuta cuando cambia userId

  if (cargando) return <div>Cargando usuario...</div>;
  if (!usuario) return <div>Selecciona un usuario</div>;

  return (
    <div>
      <h2>{usuario.name}</h2>
      <p>Email: {usuario.email}</p>
      <p>Tel√©fono: {usuario.phone}</p>
    </div>
  );
}
```

### 4. Hooks Personalizados

Los hooks personalizados permiten extraer l√≥gica reutilizable de los componentes.

#### Hook personalizado para formularios:
```jsx
function useFormulario(estadoInicial) {
  const [valores, setValores] = useState(estadoInicial);
  const [errores, setErrores] = useState({});

  const handleChange = (e) => {
    const { name, value } = e.target;
    setValores(prev => ({
      ...prev,
      [name]: value
    }));
    
    // Limpiar error del campo
    if (errores[name]) {
      setErrores(prev => ({
        ...prev,
        [name]: ''
      }));
    }
  };

  const handleSubmit = (callback) => (e) => {
    e.preventDefault();
    callback(valores);
  };

  const reset = () => {
    setValores(estadoInicial);
    setErrores({});
  };

  return {
    valores,
    errores,
    handleChange,
    handleSubmit,
    reset,
    setValores,
    setErrores
  };
}

// Uso del hook personalizado
function FormularioLogin() {
  const { valores, errores, handleChange, handleSubmit } = useFormulario({
    email: '',
    password: ''
  });

  const onSubmit = (datos) => {
    console.log('Datos del formulario:', datos);
    // L√≥gica de login
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <input
        type="email"
        name="email"
        value={valores.email}
        onChange={handleChange}
        placeholder="Email"
      />
      {errores.email && <span>{errores.email}</span>}
      
      <input
        type="password"
        name="password"
        value={valores.password}
        onChange={handleChange}
        placeholder="Contrase√±a"
      />
      {errores.password && <span>{errores.password}</span>}
      
      <button type="submit">Iniciar sesi√≥n</button>
    </form>
  );
}
```

#### Hook personalizado para API calls:
```jsx
function useApi(url) {
  const [data, setData] = useState(null);
  const [cargando, setCargando] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchData = async () => {
      try {
        setCargando(true);
        setError(null);
        const response = await fetch(url);
        const result = await response.json();
        setData(result);
      } catch (err) {
        setError(err.message);
      } finally {
        setCargando(false);
      }
    };

    if (url) {
      fetchData();
    }
  }, [url]);

  return { data, cargando, error };
}

// Uso del hook
function ListaPosts() {
  const { data: posts, cargando, error } = useApi('https://jsonplaceholder.typicode.com/posts');

  if (cargando) return <div>Cargando posts...</div>;
  if (error) return <div>Error: {error}</div>;

  return (
    <div>
      {posts.map(post => (
        <article key={post.id}>
          <h3>{post.title}</h3>
          <p>{post.body}</p>
        </article>
      ))}
    </div>
  );
}
```

### 5. Componentes Reutilizables

#### Componente Button reutilizable:
```jsx
function Button({ 
  children, 
  variant = 'primary', 
  size = 'medium', 
  onClick, 
  disabled = false,
  type = 'button'
}) {
  const baseClasses = 'btn';
  const variantClasses = {
    primary: 'btn-primary',
    secondary: 'btn-secondary',
    danger: 'btn-danger',
    success: 'btn-success'
  };
  const sizeClasses = {
    small: 'btn-sm',
    medium: 'btn-md',
    large: 'btn-lg'
  };

  const classes = [
    baseClasses,
    variantClasses[variant],
    sizeClasses[size]
  ].join(' ');

  return (
    <button
      className={classes}
      onClick={onClick}
      disabled={disabled}
      type={type}
    >
      {children}
    </button>
  );
}

// Uso del componente
function App() {
  return (
    <div>
      <Button variant="primary" onClick={() => alert('¬°Hola!')}>
        Bot√≥n Primario
      </Button>
      <Button variant="danger" size="large">
        Bot√≥n Peligro
      </Button>
      <Button variant="success" disabled>
        Bot√≥n Deshabilitado
      </Button>
    </div>
  );
}
```

#### Componente Modal reutilizable:
```jsx
function Modal({ 
  isOpen, 
  onClose, 
  title, 
  children, 
  size = 'medium' 
}) {
  if (!isOpen) return null;

  const sizeClasses = {
    small: 'modal-sm',
    medium: 'modal-md',
    large: 'modal-lg'
  };

  return (
    <div className="modal-overlay" onClick={onClose}>
      <div 
        className={`modal ${sizeClasses[size]}`}
        onClick={(e) => e.stopPropagation()}
      >
        <div className="modal-header">
          <h2>{title}</h2>
          <button className="modal-close" onClick={onClose}>
            √ó
          </button>
        </div>
        <div className="modal-body">
          {children}
        </div>
      </div>
    </div>
  );
}

// Uso del modal
function App() {
  const [modalAbierto, setModalAbierto] = useState(false);

  return (
    <div>
      <button onClick={() => setModalAbierto(true)}>
        Abrir Modal
      </button>
      
      <Modal
        isOpen={modalAbierto}
        onClose={() => setModalAbierto(false)}
        title="Mi Modal"
        size="large"
      >
        <p>Este es el contenido del modal.</p>
        <p>Puedes poner cualquier contenido aqu√≠.</p>
      </Modal>
    </div>
  );
}
```

### 6. Optimizaci√≥n con React.memo

`React.memo` evita re-renderizados innecesarios de componentes:

```jsx
const UsuarioCard = React.memo(function UsuarioCard({ usuario, onEdit }) {
  console.log('UsuarioCard renderizado');
  
  return (
    <div className="usuario-card">
      <h3>{usuario.nombre}</h3>
      <p>{usuario.email}</p>
      <button onClick={() => onEdit(usuario.id)}>
        Editar
      </button>
    </div>
  );
});

// Componente padre
function ListaUsuarios() {
  const [usuarios, setUsuarios] = useState([]);
  const [filtro, setFiltro] = useState('');

  const handleEdit = useCallback((userId) => {
    console.log('Editando usuario:', userId);
  }, []);

  const usuariosFiltrados = usuarios.filter(usuario =>
    usuario.nombre.toLowerCase().includes(filtro.toLowerCase())
  );

  return (
    <div>
      <input
        value={filtro}
        onChange={(e) => setFiltro(e.target.value)}
        placeholder="Filtrar usuarios..."
      />
      
      {usuariosFiltrados.map(usuario => (
        <UsuarioCard
          key={usuario.id}
          usuario={usuario}
          onEdit={handleEdit}
        />
      ))}
    </div>
  );
}
```

## üõ†Ô∏è Ejercicios Pr√°cticos

### **Ejercicio 1: Timer con useEffect**
Crea un componente `Timer` que muestre un contador que se incrementa cada segundo, con botones para pausar, reanudar y resetear.

### **Ejercicio 2: Hook Personalizado para Contador**
Crea un hook personalizado `useContador` que maneje la l√≥gica de un contador y √∫salo en m√∫ltiples componentes.

### **Ejercicio 3: Lista de Usuarios con API**
Crea un componente que consuma una API (como JSONPlaceholder) y muestre una lista de usuarios con b√∫squeda y filtrado.

### **Ejercicio 4: Formulario de Registro**
Crea un formulario de registro completo con validaci√≥n, usando el hook personalizado `useFormulario`.

### **Ejercicio 5: Componente Modal Reutilizable**
Crea un componente `Modal` completamente reutilizable que pueda mostrar cualquier contenido.

### **Ejercicio 6: Hook para LocalStorage**
Crea un hook personalizado `useLocalStorage` que sincronice el estado con localStorage.

### **Ejercicio 7: Lista de Tareas con Persistencia**
Crea una lista de tareas que persista los datos en localStorage usando useEffect.

### **Ejercicio 8: Componente de B√∫squeda**
Crea un componente de b√∫squeda que use debouncing para evitar llamadas innecesarias a la API.

### **Ejercicio 9: Hook para Ventana**
Crea un hook personalizado `useWindowSize` que detecte cambios en el tama√±o de la ventana.

### **Ejercicio 10: Componente de Paginaci√≥n**
Crea un componente de paginaci√≥n reutilizable que funcione con cualquier lista de datos.

## üéØ Proyecto Integrador: Lista de Tareas

### **Descripci√≥n del Proyecto**
Construye una aplicaci√≥n completa de gesti√≥n de tareas que incluya creaci√≥n, edici√≥n, eliminaci√≥n, marcado como completada, filtros, b√∫squeda y persistencia de datos.

### **Requisitos del Proyecto**
- ‚úÖ CRUD completo de tareas (Crear, Leer, Actualizar, Eliminar)
- ‚úÖ Filtros por estado (todas, pendientes, completadas)
- ‚úÖ B√∫squeda en tiempo real
- ‚úÖ Persistencia en localStorage
- ‚úÖ Categor√≠as de tareas
- ‚úÖ Fechas de vencimiento
- ‚úÖ Prioridades (baja, media, alta)
- ‚úÖ Estad√≠sticas de tareas
- ‚úÖ Interfaz responsive y moderna
- ‚úÖ Hooks personalizados para l√≥gica reutilizable

### **Estructura de Componentes Sugerida**
```
App/
‚îú‚îÄ‚îÄ Header/
‚îú‚îÄ‚îÄ TaskForm/
‚îú‚îÄ‚îÄ TaskList/
‚îÇ   ‚îú‚îÄ‚îÄ TaskItem/
‚îÇ   ‚îî‚îÄ‚îÄ TaskFilters/
‚îú‚îÄ‚îÄ TaskStats/
‚îú‚îÄ‚îÄ useTasks (hook personalizado)
‚îú‚îÄ‚îÄ useLocalStorage (hook personalizado)
‚îî‚îÄ‚îÄ useDebounce (hook personalizado)
```

## üìù Autoevaluaci√≥n

### **Preguntas de Repaso**
1. ¬øCu√°ndo se ejecuta useEffect sin array de dependencias?
2. ¬øC√≥mo se implementa la limpieza en useEffect?
3. ¬øCu√°l es la diferencia entre useEffect y useLayoutEffect?
4. ¬øC√≥mo se crean hooks personalizados?
5. ¬øQu√© es React.memo y cu√°ndo se usa?
6. ¬øC√≥mo se manejan las llamadas a APIs con useEffect?
7. ¬øCu√°les son las mejores pr√°cticas para useEffect?

### **Criterios de Evaluaci√≥n**
- ‚úÖ Usar useEffect correctamente para efectos secundarios
- ‚úÖ Implementar limpieza de efectos y suscripciones
- ‚úÖ Crear hooks personalizados reutilizables
- ‚úÖ Manejar llamadas a APIs de manera efectiva
- ‚úÖ Crear componentes reutilizables y modulares
- ‚úÖ Optimizar re-renderizados con React.memo
- ‚úÖ Implementar formularios complejos con validaci√≥n
- ‚úÖ Manejar estado local y efectos secundarios

## üîë Conceptos Clave a Recordar

- **useEffect** maneja efectos secundarios y ciclo de vida
- **Array de dependencias** controla cu√°ndo se ejecuta useEffect
- **Funci√≥n de limpieza** evita memory leaks
- **Hooks personalizados** extraen l√≥gica reutilizable
- **React.memo** optimiza re-renderizados
- **useCallback** y **useMemo** optimizan funciones y valores
- **Componentes reutilizables** mejoran la mantenibilidad
- **LocalStorage** permite persistencia de datos

## üöÄ Vista Previa del Siguiente Nivel

En el siguiente m√≥dulo aprender√°s sobre React Router para navegaci√≥n entre p√°ginas, manejo de estado m√°s complejo, y c√≥mo estructurar aplicaciones multi-p√°gina.

## üìö Recursos Adicionales

- [useEffect Hook](https://react.dev/reference/react/useEffect)
- [Hooks Personalizados](https://react.dev/learn/reusing-logic-with-custom-hooks)
- [React.memo](https://react.dev/reference/react/memo)
- [useCallback y useMemo](https://react.dev/reference/react/useCallback)
- [Ciclo de Vida en Hooks](https://react.dev/learn/lifecycle-of-reactive-effects)

## ‚úÖ Checklist de Competencias

- [ ] Entiendo y uso useEffect correctamente
- [ ] Comprendo el ciclo de vida de componentes funcionales
- [ ] Creo componentes reutilizables y modulares
- [ ] Manejo efectos secundarios (API calls, suscripciones)
- [ ] Implemento limpieza de efectos y suscripciones
- [ ] Creo hooks personalizados b√°sicos
- [ ] Manejo formularios complejos con validaci√≥n
- [ ] Implemento navegaci√≥n b√°sica entre componentes
- [ ] Optimizo re-renderizados con React.memo
- [ ] Completo el proyecto integrador de lista de tareas

---

**¬°Excelente progreso! Has dominado los hooks b√°sicos y est√°s listo para el siguiente nivel.** üéâ
